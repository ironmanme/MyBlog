[{"title":"前端性能优化","url":"%2FwebOptimize.html","content":"\n{% fi https://cdn.lishaoy.net/webOptimize/Optimize.png, web optimize, web optimize %}\n\n关于 **性能优化** 是个大的面，这篇文章主要涉及到 **前端** 的几个点，如 **前端性能优化** 的流程、常见技术手段、工具等。\n\n提及 **前端性能优化** ，大家应该都会想到 **雅虎军规**，本文会结合 **雅虎军规** 融入自己的了解知识，进行的总结和梳理 😜\n\n<!-- more -->\n\n首先，我们先来看看 👀 **雅虎军规** 的 **35** 条。\n\n{% note info %} \n1. 尽量减少 **HTTP** 请求个数——须权衡\n2. 使用 **CDN**（内容分发网络）\n3. 为文件头指定 `Expires` 或 `Cache-Control` ，使内容具有缓存性。\n4. 避免空的 `src` 和 `href`\n5. 使用 `gzip` 压缩内容\n6. 把 `CSS` 放到顶部\n7. 把 `JS` 放到底部\n8. 避免使用 `CSS` 表达式\n9. 将 `CSS` 和 `JS` 放到外部文件中\n10. 减少 **DNS** 查找次数\n11. 精简 `CSS` 和 `JS`\n12. 避免跳转\n13. 剔除重复的 `JS` 和 `CSS`\n14. 配置 **ETags**\n15. 使 **AJAX** 可缓存\n16. 尽早刷新输出缓冲\n17. 使用 **GET** 来完成 **AJAX** 请求\n18. 延迟加载\n19. 预加载\n20. 减少 **DOM** 元素个数\n21. 根据域名划分页面内容\n22. 尽量减少 `iframe` 的个数\n23. 避免 **404**\n24. 减少 `Cookie` 的大小\n25. 使用无 `cookie` 的域\n26. 减少 **DOM** 访问\n27. 开发智能事件处理程序\n28. 用 `<link>` 代替 `@import`\n29. 避免使用滤镜\n30. 优化图像\n31. 优化 `CSS Spirite`\n32. 不要在 `HTML` 中缩放图像——须权衡\n33. favicon.ico要小而且可缓存\n34. 保持单个内容小于25K\n35. 打包组件成复合文本\n{% endnote %}  \n\n如对 **雅虎军规** 的具体细则内容不是很了解，可自行去各搜索 🔍 引擎 ，搜索 **雅虎军规** 了解详情。\n\n### 压缩 合并\n\n对于 **前端性能优化** 自然要关注 **首屏** 打开速度，而这个速度，很大因素是花费在网络请求上，那么怎么减少网络请求的时间呢？\n\n- 减少网络请求次数 \n- 减小文件体积\n- 使用 `CDN` 加速\n\n所以 **压缩、合并** 就是一个解决方案，当然可以用 `gulp` 、 `webpack` 、 `grunt` 等构建工具 **压缩、合并**\n\n例如：`gulp` 代码如下 👇\n\n```javascript gulpfile.js\n//合并js\ngulp.task('scripts', function () {\n    return gulp.src([\n        './public/lib/fastclick/lib/fastclick.min.js',\n        './public/lib/jquery_lazyload/jquery.lazyload.js',\n        './public/lib/velocity/velocity.min.js',\n        './public/lib/velocity/velocity.ui.min.js',\n        './public/lib/fancybox/source/jquery.fancybox.pack.js',\n        './public/js/src/utils.js',\n        './public/js/src/motion.js',\n        './public/js/src/scrollspy.js',\n        './public/js/src/post-details.js',\n        './public/js/src/bootstrap.js',\n        './public/js/src/push.js',\n        './public/live2dw/js/perTips.js',\n        './public/live2dw/lib/L2Dwidget.min.js',\n        './public/js/src/love.js',\n        './public/js/src/busuanzi.pure.mini.js',\n        './public/js/src/activate-power-mode.js'\n    ]).pipe(concat('all.js')).pipe(minify()).pipe(gulp.dest('./public/dist/'));\n});\n```\n然后，再把 **压缩、合并** 的文件放入 `CDN` , 👀 看看效果如何\n\n如图：* **压缩、合并** 且放入 `CND` 之后的效果 *\n\n<img src=\"https://cdn.lishaoy.net/webOptimize/concatJs.png\" alt=\"Netlity\" width=\"100%\" title=\"首页请求速度\" align=\"center\" />\n\n以上是 [lishaoy.net](https://lishaoy.net) 清除缓存后的 **首页** 请求速度。\n\n可见，请求时间是 **4.59 s** ，总请求个数 **51** ， 而 `js` 的请求个数是 **8** ，而没使用 **压缩、合并** 时候，请求时间是 **10** 多秒，总请求个数有 **70** 多个，`js` 的请求个数是 **20** 多个 ，对比请求时间 **性能** 提升 **1倍** 多\n\n如图：*缓存下的首页效果*\n\n<img src=\"https://cdn.lishaoy.net/webOptimize/concatJs2.png\" alt=\"Netlity\" width=\"100%\" title=\"首页请求速度（缓存）\" align=\"center\" />\n\n基本都是秒开 😝\n\n{% note warning %}\n*Tips：在 `压缩、合并` 后，单个文件控制在 25 ~ 30 KB左右，同一个域下，最好不要多于5个资源*\n{% endnote %} \n\n### 未完，待续。。。 😜\n","tags":["web"],"categories":["性能"]},{"title":"Promise诞生记","url":"%2FcreatePromise.html","content":"\n{% fi createPromise/promise.png, Promise, Promise %}\n\n前端近年的兴起，有大部分是因为 `NodeJS` 的诞生，而 `NodeJS` 是个适用于 **异步IO** 密集型的语言，一些基于 `NodeJS` 的框架，比喻 *KOA2、Adonis* 就有大量的 `async` 和 `await` 语法，`async`的函数的返回值就是 `Promise` 对象，我们可以用 `async` 和 `await` 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。\n\n这里我们会渐进式的来创建一个 `Promise` 的实现，如果，你还不了解 `Promise` ，赶快移步 [Promise](http://es6.ruanyifeng.com/#docs/promise) 了解学习，当然这个实现会符合 [Promise/A+](https://promisesaplus.com) 规范，`JavaScript` 中有很多第三方的 `Promise` 库，[bluebird](http://bluebirdjs.com/docs/getting-started.html) 就是一个第三方 `Promise` 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。\n\n---\n\n<!-- more -->\n\n废话不多说，直接开干。。。 😠\n\n## 定义 Promise 类型\n\n一个简单 `Promise` 语法，如下\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... doSomething\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n### 实现 resolve 和 then\n\n首先我们以上 👆 的语法，自己定义一个 `Promise` 实例\n\n```javascript\nfunction Promise(fn) {\n  var callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    callback(value);\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n一个简单的实例写好了，然后，来用一下,看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n```\n\n\n{% note info %}\n\n执行结果是：`callback is not a function`\n\n{% endnote %}\n\n### 修改 callback 为异步\n\n**这里就遇到一个问题： **  \n\n** 发现 `resolve()` 在 `then()` 之前调用，在 `resolve()` 被调用的时候， `callback` 还是 `null` ，我们的代码是同步的，而不是异步的。</br> 如是，想办法解决掉这个问题，就是利用 `setTimeout` , 把 `callback` 加入异步队列** \n\n代码如下 👇\n\n```javascript\nfunction Promise(fn) {\n  var callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    // 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法\n    setTimeout(function(){\n      callback(value);\n    },1)\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n然后，再来用一下,看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n```\n\n{% note info %}\n\n执行结果是：`66`\n\n{% endnote %}\n\n## 未完待续。。。\n","tags":["Promise"],"categories":["JS"]},{"title":"IVAN AIVAZOVSKY 赏析","url":"%2FIVANAIVAZOVSKY.html","content":"\n{% fi IVANAIVAZOVSKY/home.png, IVAN AIVAZOVSKY, IVAN AIVAZOVSKY %}\n\n*在 [awwwards][1] 上发现一个设计和交互超级棒的网页  [ivanaivazovsky.life][2]，整个设计非常简洁大胆，色彩基本只有黑白色，看起来非常舒服，直接看效果吧！* 🍷 \n\n---\n\n<!-- more -->\n\n#### HOME\n网页加载完成后，显示的首页，加载首页有一个动画效果，有一层烟雾慢慢散开，然后才出现人物。\n\n这个页面非常简洁\n上面：MENU 、SOUND.ON（音乐开关）、和 语言的切换\n下面：200周年小logo、ABOUT（关于）、CREDITS（大概是工作人员名单的意思）\n\n{% fi IVANAIVAZOVSKY/home.png, home, home %}\n\n#### MENU\n菜单的设计是全屏的，每个菜单都有一个背景图，觉得这个设计简洁而且大气。\n\n{% fi IVANAIVAZOVSKY/menu.png, menu, menu %}\n\n#### WORKS\n进来会显示所有的作品，左边有个分类菜单（FILTER）\n\n{% fi IVANAIVAZOVSKY/works1.png, works, works %}\n\n<br />\n分类菜单（FILTER），非常的简洁，没有任何文字描述，鼠标放上去会有一个简单的介绍\n\n{% fi IVANAIVAZOVSKY/works2.png, works, works %}\n<br />\n点击每个作品，可以进来详情页面，页非常简洁，黑框框的简介，这个不能收进去，如果能收进去就更好了\n\n{% fi IVANAIVAZOVSKY/works-item1.png, works-item, works-item %}\n<br />\n点击黑色的加，可以进入详细介绍，黑底白字，一个小叉叉，简洁舒服\n\n{% fi IVANAIVAZOVSKY/works-item2.png, works-item, works-item %}\n<br />\n点击 VIEW ALL PAINTINGS 可以显示缩小的视图，方便随意切换，这个设计也是棒棒的\n\n{% fi IVANAIVAZOVSKY/works-item3.png, works-item, works-item %}\n\n大的文字导航，漂亮的图片背景，鼠标放到每个菜单上背景图可以对应切换\n\n{% fi IVANAIVAZOVSKY/life.png, life, life %}\n<br />\n点击菜单进入live详情，这里还有一个小动画\n\n{% fi IVANAIVAZOVSKY/life-item1.png, life-item, life-item %}\n<br />\n点击 ARCHIVE 可以总预览界面\n\n{% fi IVANAIVAZOVSKY/life-item2.png, life-item, life-item %}\n\n#### AWARDS\n\n{% fi IVANAIVAZOVSKY/awards.png, awards, awards %}\n#### MAP\n这个界面也是超简洁，把鼠标放在圆点上出来简介\n\n{% fi IVANAIVAZOVSKY/map1.png, map, map %}\n<br />\n点击简介，进入详情，左下角的 NEXT 可以切换图片\n\n{% fi IVANAIVAZOVSKY/map2.png, map, map %}\n忘了介绍 左右上角中间 有个导航，告诉你的位置，也方便回到主页\n\n\n  [1]: https://www.awwwards.com\n  [2]: http://ivanaivazovsky.life","tags":["设计"],"categories":["设计"]},{"title":"CSSModules","url":"%2FCSSModules.html","content":"\n{% fi CSSModules/cssmodules.png, CSS Modules, CSS Modules %}\n\n这篇文章来一起了解 `css` 模块化的用法和原理 ，**dome** 地址：[css modules](https://github.com/persilee/webpack_test) 😮\n\n---\n\n<!-- more -->\n\n#### 局部作用域\n\n一般我们引入页面的 `CSS` 的作用域都是全局的，都是对这个页面起作用，产生局部的作用域，就是使用一个独一无二的 `class` 的名称，不会和其它选择器重名的， **`CSS Modules`** 就是这个原理。下面我们看一段代码\n\n```javascript\nimport $ from 'jquery';\nimport styles from './main.css';\nimport test from './test.html';\n\n$('body').append($('<div><h1>我会变绿</h1></div>'));\n$('div h1').addClass(styles.testGreen);\n$('body').append(test).find('h2').addClass(styles.testBlue);\n```\n\n上面的代码我把 `main.css` 输入到 `style` 对象，然后下面用了 `styles.testGreen` 对象的属性形式调用，就会应用 `main.css` 里的样式\n\n```css\n.testGreen {\n  color: green;\n}\n```\n\n构建工具（ `webpack` ）编译成一个哈希字符串\n\n```vbscript-html\n<div>\n    <h1 class=\"_305zeUSoiGREv3GqPa9H8F\">我会变绿</h1>\n</div>\n```\n\n`main.css` 也会同时编译\n\n```css\n._305zeUSoiGREv3GqPa9H8F {\n  color: #aaf200;\n}\n```\n\n这样一来，这个类名就是独一无二的了，只对应用的组件有效。\n**`CSS Modules`** 支持不同的构建工具，这里我使用的是 `webpack` ,下文都是以 `webpack` 为例。\n\n下面我们来看下 **`webpack.config.js`**\n\n```javascript\nmodule.exports = {\n  context: __dirname + '/src',\n  devtool: 'eval-source-map', //配置生成Source Maps，选择合适的选项\n  entry: {\n    app: ['./app.js', './test.js'],\n  },\n  output: {\n    path: __dirname + '/dist',\n    filename: 'bundle.js',\n    publicPath: '/assets',\n  },\n  module: {\n    loaders: [\n      {test: /\\.json$/,loader: 'json-loader'},\n      {test: /\\.js$/,exclude: /node_modules/,loader: 'babel-loader'},\n      {test: /\\.css$/,loader: ExtractTextPlugin.extract({\n          fallbackLoader: \"style-loader\",\n          loader: {\n            loader: \"css-loader\",\n            query: {\n              modules: true\n            }\n          }\n        })\n      },\n      {test: /\\.html$/,loader: 'html-loader'},\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin('style.css')\n  ]\n};\n```\n\n上面的代码可以看到，`query:{modules:true}` 代表开启 **`CSS Modules`** 模块，这里还配置了把所以得 `css` 合并一个文件，具体的可以了解 `webpack` 的 `extract-text-webpack-plugin`插件。\n\n#### 全局作用域\n\n**`CSS Modules`** 允许用 `:global(.className)` 的语法声明一个全局的作用域。加了 `:global` 的不会被编译成哈希值。\n\n```css\n:global(.title) {\n  color: black;\n}\n\n.title {\n  color: red;\n}\n```\n\n`test.js` 使用普通的写法，就会引用全局的 `.title` 的样式\n\n```javascript\nimport $ from 'jquery';\nimport styles from './main.css';\nimport test from './test.html';\n\n$('body').append($('<div><h1>我是title</h1></div>'));\n$('div h1').addClass('title');\n```\n\n结果 `h1` 的title显示黑色。\n\n#### Class的组合\n\n在 **`CSS Modules`** 里，一个选择器可以继承另一个选择器。\n\n在 `mian.css` 里，我让 `.testBlue` 继承 `.testBg` 类\n\n```css\n.testBg {\n  background-color: red;\n}\n\n.testBlue {\n  color: blue;\n  composes: testBg;\n}\n\n```\n不用修改 `test.js` ,应用了 `.testBlue` 就会有一个红色的背景。\n\n编译结果：\n\n```css\n.eh33VC37uFHXkCZ8LfKYd {\n  background-color: #ff0000;\n}\n\n.xrmZso54fTBX29J9G65Ai {\n  color: #0c77f8;\n}\n```\n\n相应的 `html` 代码：\n\n```html\n<h3 class=\"xrmZso54fTBX29J9G65Ai eh33VC37uFHXkCZ8LfKYd _2gsuNWm9029FHPYJP62C-t\">\n    我会变蓝\n</h3>\n```\n\n#### 输入变量\n\n**`CSS Modules`** 支持使用变量，不过要安装 **PsotCSS** 和 **postcss-modules-values**。\n\n```vim\n$ npm install --save postcss-loader postcss-modules-values\n```\n\n把 `postcss-loader` 加入 `webpack.config.js` .\n\n```javascript\n{\n    test: /\\.css$/,\n    loader: 'style-loader!css-loader?modules!postcss-loader'\n},\n```\n\n然后我在 `colors.css` 里定义了一些变量。\n\n```css\n@value blue: #0c77f8;\n@value red: #ff0000;\n@value green: #aaf200;\n```\n\n在 `main.css` 里可以这样引用变量\n\n```css\n@value colors: \"./color.css\";\n@value blue, red, green from colors;\n\n.title {\n  color: red;\n}\n\n.testBg {\n  background-color: red;\n}\n\n.testGreen {\n  color: green;\n}\n\n.testBlue {\n  color: blue;\n  composes: testBg;\n  composes: div;\n}\n```\n\n这样就可以把 `colors.css` 的变量拿过来用了，是不是很神奇。","tags":["modules"],"categories":["CSS"]},{"title":"如何使用 markdown 语法写博客","url":"%2FmarkdownGrammar.html","content":"\n{% fi markdownGrammar/markdown.png, markdown, markdown %}\n\n平时我写日记、文档和博客都会用到 `markdown` 语法，我用的是 `马克飞象` 先在本地写好，而且可以和 `印象笔记` 同步，如果知识积累的多了，也会总结下，分享到社区，直接 <kbd>⌘ -  C</kbd>  然后 <kbd>⌘ -  V</kbd>  就可以了，特别方便。 🙂\n\n---\n\n<!-- more -->\n\n### 什么是Markdown语法\n`Markdown` 是一种轻量级标记语言，目标是实现「易读易写」。\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— [维基百科](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n### 标题\n**在 `Markdown` 中，你只需要在文本前面加上 `#` 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 `#` 即可，标题字号相应降低。例如：**\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n效果如下 ：\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n---\n### 引用\n**`Markdown` 标记区块引用是使用类似 email 中用的引用方式，只需要在整个段落的第一行最前面加上 > 。**\n例如：\n```\n>这是一个引用示例\n```\n效果如下：\n\n>这是一个引用示例\n\n**区块引用可以嵌套，只要根据层次加上不同数量的 > ：**\n\n```vim\n> 这是第一级引用。\n>\n> > 这是第二级引用。\n>\n> 现在回到第一级引用。\n```\n效果如下：\n> 这是第一级引用。\n>\n> > 这是第二级引用。\n>\n> 现在回到第一级引用。\n\n---\n### 列表\n**Markdown 支持有序列表和无序列表。**\n\n1. 无序列表使用星号、加号或是减号作为列表标记：\n\n```vim\n*   Red\n*   Green\n*   Blue\n```\n等同于\n```vim\n+   Red\n+   Green\n+   Blue\n```\n也等同于\n```vim\n-   Red\n-   Green\n-   Blue\n```\n效果如下：\n-   Red\n-   Green\n-   Blue\n\n----\n\n2. 有序列表则使用数字接着一个英文句点：\n\n```vim\n1.  Bird\n2.  McHale\n3.  Parish\n```\n效果如下：\n1.  Bird\n2.  McHale\n3.  Parish\n\n如果你的列表标记写成：\n```vim\n1.  Bird\n1.  McHale\n1.  Parish\n```\n效果是：\n1.  Bird\n1.  McHale\n1.  Parish\n\n甚至是：\n```vim\n3. Bird\n1. McHale\n8. Parish\n```\n效果是：\n3. Bird\n1. McHale\n8. Parish\n\n可以看到，数字还是正常的，所以，你可以让 `Markdown` 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\n\n如果要在列表项目内放进引用，那 > 就需要缩进：\n```vim\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n```\n效果如下：\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n\n---\n\n### 代码区块\n\n只要把你的代码块包裹在  <code>\\`\\`\\`</code>  之间，你就不需要通过无休止的缩进来标记代码块了。 在围栏式代码块中，你可以指定一个可选的语言标识符，然后我们就可以为它启用语法着色了。 举个例子，这样可以为一段 `Ruby` 代码着色：\n\n<code>\n\\`\\`\\`ruby </br>\nrequire 'redcarpet' </br>\nmarkdown = Redcarpet.new(\"Hello World!\") </br>\nputs markdown.to_html </br>\n\\`\\`\\`\n</code>\n\n效果如下：\n\n```ruby\n    require 'redcarpet'\n    markdown = Redcarpet.new(\"Hello World!\")\n    puts markdown.to_html\n```\n\n---\n\n### 强调\n在 `Markdown` 中，可以使用 \\* 和 \\_ 来表示斜体和加粗。\n\n斜体：\n\n```vim\n*Coding，让开发更简单*\n_Coding，让开发更简单_\n```\n效果如下：\n\n*Coding，让开发更简单* </br>\n_Coding，让开发更简单_\n\n加粗：\n\n```vim\n**Coding，让开发更简单**\n__Coding，让开发更简单__\n```\n效果如下：\n\n**Coding，让开发更简单** </br>\n__Coding，让开发更简单__\n\n---\n\n### 代码\n如果要标记一小段行内代码，你可以用反引号把它包起来 <code>\\`\\`\\`</code> ，例如：\n\n```vim\nUse the `printf()` function.\n```\n效果如下：\n\nUse the `printf()` function.\n\n---\n\n### 自动链接\n`Markdown` 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来，`Markdown` 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n```css\n<http://example.com/>\n```\n效果如下：\n\n<http://example.com/>\n\n### 链接\n`Markdown` 支持两种形式的链接语法： *行内式* 和 *参考式* 两种形式。我个人比较喜欢用 *参考式* 。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n1. *行内式* 的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 `title` 文字，只要在网址后面，用双引号把 `title` 文字包起来即可，例如：\n\n```\nThis is [an example](http://example.com/ \"Title\") inline link.\n```\n效果如下：\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n---\n\n### 图片\n`Markdown` 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： *行内式* 和 *参考式* 。\n\n1. 行内式的图片语法看起来像是：\n\n```\n![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg \"Optional title\")\n```\n详细叙述如下：\n\n- 一个惊叹号 `!`\n- 接着一个方括号，里面放上图片的替代文字\n- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 `title` 文字。\n\n---\n\n2. 参考式的图片语法则长得像这样：\n\n```lasso\n![Alt text][id]\n```\n`id` 是图片参考的名称，图片参考的定义方式则和连结参考一样：\n```lasso\n[id]: url/to/image  \"Optional title attribute\"\n```\n`Markdown` 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `<img>`  标签。\n\n---\n\n### LaTeX 公式\n\n可以创建行内公式，例如 :\n```\n$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n```\n效果如下：\n\n$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n\n或者块级公式：\n```\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n```\n效果如下：\n\n$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n---\n\n### 表格\n\n```lasso\n| Item      |    Value | Qty  |\n| :-------- | --------:| :--: |\n| Computer  | 1600 USD |  5   |\n| Phone     |   12 USD |  12  |\n| Pipe      |    1 USD | 234  |\n```\n\n效果如下：\n\n| Item      |    Value | Qty  |\n| :-------- | --------:| :--: |\n| Computer  | 1600 USD |  5   |\n| Phone     |   12 USD |  12  |\n| Pipe      |    1 USD | 234  |\n\n\n---\n\n### 流程图\n\n<code>\n\\`\\`\\`flow </br>\nst=>start: Start </br>\ne=>end </br>\nop=>operation: My Operation </br>\ncond=>condition: Yes or No? </br>       \nst->op->cond </br>\ncond(yes)->e </br>\ncond(no)->op </br>\n\\`\\`\\`\n</code>\n\n效果如下：\n\n```flow\nst=>start: Start\ne=>end\nop=>operation: My Operation\ncond=>condition: Yes or No?\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n以及时序图:\n\n<code>\n\\`\\`\\`sequence </br>\nAlice->Bob: Hello Bob, how are you? </br>\nNote right of Bob: Bob thinks </br>\nBob-->Alice: I am good thanks! </br>\n\\`\\`\\`\n</code>\n\n效果如下：\n\n```sequence\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n### 复选框\n\n使用 `- [ ]` 和 `- [x]` 语法可以创建复选框，实现 todo-list 等功能。例如：\n\n```lasso\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n```\n效果如下：\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n---\n\n### 分割线\n在 `Markdown` 中，可以制作分割线，例如：\n\n```lasso\n    ---\n```\n效果如下：\n\n--- \n\n### 反斜杠\n\n`Markdown` 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n```\n\\*literal asterisks\\*\n```\n效果如下：\n\n\\*literal asterisks\\*\n\n`Markdown` 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\n```\n  \\   反斜线\n  `   反引号\n  *   星号\n  _   底线\n  {}  花括号\n  []  方括号\n  ()  括弧\n  #   井字号\n  +   加号\n  -   减号\n  .   英文句点\n  !   惊叹号\n```\n","tags":["markdown"],"categories":["工具"]},{"title":"被遗忘的CSS","url":"%2FupsetCssSummary.html","content":"\n{% fi upsetCssSummary/css.png, css, css %}\n\n平时在工作中遇到一些比较偏门的 `css` ，用过一两次，但是老是记不住，于是又需要去 **baidu、 google** ，所以都积累起来，方便以后查看（持续更新...） 😀\n\n---\n\n<!-- more -->\n\n#### `outline`  **当input选中的时候会出现一个边框**\n\n```css\n/*一般设置成 none*/\ntextarea:focus, input:focus{\n    outline: none;\n}\n```\n#### `contenteditable` **规定元素内容是否可编辑**\n\n```vbscript-html\n<div id=\"example-one\" contenteditable=\"true\">\n```\n\n```css\n#example-one { \n    margin-bottom: 10px; \n}\n[contenteditable=\"true\"] { \n    padding: 10px; outline: 2px dashed #CCC; \n}\n[contenteditable=\"true\"]:hover { \n    outline: 2px dashed #0090D2; \n}\n```\n#### `webkit-playsinline` **video 都可以在页面中播放，而不是全屏播放**\n\n```vbscript-html\n<video id=\"myvideo\" src=\"test.mp4\" webkit-playsinline=\"true\"></video>\n```\n\n#### `clearfix` **清除浮动**\n\n```css\n.clearfix {\n    zoom: 1;\n}\n.clearfix:after {\n     visibility: hidden;\n     display: block;\n     font-size: 0;\n     content: \" \";\n     clear: both;\n     height: 0;\n }\n```\n#### `user-select ` **禁止选中文本**\n\n```css\np {\n    -webkit-user-select: none; /* Chrome, Opera, Safari */\n    -moz-user-select: none; /* Firefox 2+ */\n    -ms-user-select: none; /* IE 10+ */\n    user-select: none; /* Standard syntax */\n}\n```\n#### `webkit-scrollbar` **自定义浏览器滚动条**\n\n```css\n/*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/\n\ndiv::-webkit-scrollbar {\n    width: 5px;\n    height: 5px;\n    background-color: rgba(245, 245, 245, 0.47);\n}\n\n/*定义滚动条的轨道，内阴影及圆角*/\n\ndiv::-webkit-scrollbar-track {\n    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);\n    border-radius: 10px;\n    background-color: #f5f5f5;\n}\n\n/*定义滑块，内阴影及圆角*/\n\ndiv::-webkit-scrollbar-thumb {\n    /*width: 10px;*/\n    height: 20px;\n    border-radius: 10px;\n    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);\n    background-color: rgba(85, 85, 85, 0.25);\n}\n```\n\n#### `webkit-appearance` **去除默认样式**\n\n```css\ninput, button, textarea, select {\n    *font-size: 100%;\n    -webkit-appearance:none;\n}\n```\n#### **使用CSS transforms 或者 animations时可能会有页面闪烁的bug**\n\n```css\nelements {\n     -webkit-backface-visibility: hidden; \n}\n```\n#### `transform-style: preserve-3d` **让元素支持3D**\n\n```css\nelements {\n    -webkit-transform: rotateY(60deg); /* Chrome, Safari, Opera */\n    -webkit-transform-style: preserve-3d; /* Chrome, Safari, Opera */\n    transform: rotateY(60deg);\n    transform-style: preserve-3d;\n}\n```\n#### `perspective` **这个属性定义子元素会获得透视效果，而不是元素本身**\n\n```vbscript-html\n<div class=\"cube pers250\">\n    <div class=\"face front\">1</div>\n    <div class=\"face back\">2</div>\n    <div class=\"face right\">3</div>\n    <div class=\"face left\">4</div>\n    <div class=\"face top\">5</div>\n    <div class=\"face bottom\">6</div>\n</div>\n```\n```css\n.cube {\n  width: 100%;\n  height: 100%;\n  backface-visibility: visible;\n  perspective-origin: 150% 150%;\n  transform-style: preserve-3d;\n  -webkit-backface-visibility: visible;\n  -webkit-perspective-origin: 150% 150%;\n  -webkit-transform-style: preserve-3d;\n}\n.pers250 {\n  perspective: 250px;\n  -webkit-perspective: 250px;\n}\n.face {\n  display: block;\n  position: absolute;\n  width: 100px;\n  height: 100px;\n   border: none;\n  line-height: 100px;\n  font-family: sans-serif;\n  font-size: 60px;\n  color: white;\n  text-align: center;\n}\n```\n#### **css实现不换行、自动换行、强制换行**\n\n```css\n/*不换行*/\nwhite-space:nowrap;\n\n/*自动换行*/\nword-wrap: break-word; \nword-break: normal; \n\n/*强制换行*/\nword-break:break-all;\n```\n\n#### `font-smoothing` **设置字体平滑，会让字体看起来比较舒服**\n\n```css\nh1, .h1, h2, .h2, h3, .h3, h4, .h4, h5, .h5, h6, .h6, p, .navbar, .brand, a, .td-name, td {\n    -moz-osx-font-smoothing: grayscale;\n    -webkit-font-smoothing: antialiased;\n    font-family: \"Microsoft YaHei\", \"微软雅黑\", 'Muli', \"Helvetica\", Arial, sans-serif;\n}\n```\n#### `::selection` **修改选中文本颜色**\n\n```css\n::selection {\n\tcolor: white;\n\tbackground-color: rgba(0, 0, 0, 0.8);\n}\n::-webkit-selection {\n\tcolor: white;\n\tbackground-color: rgba(0, 0, 0, 0.8);\n}\n::-moz-selection {\n\tcolor: white;\n\tbackground-color: rgba(0, 0, 0, 0.8);\n}\n```","tags":["css"],"categories":["CSS"]},{"title":"PHP ThinkPHP 初识","url":"%2FphpThinkPHPBasis.html","content":"\n{% fi phpThinkPHPBasis/php.png, php && thinkPHP 基础, php && thinkPHP 基础 %}\n\n这篇文章主要带大家认识一下 `PHP` 、 `thinkPHP` ，都是一下基础，其中包括 **PHP语法（变量、字符串、数组、表单、数据库）** 、**面向对象（Class创建、属性、继承、访问控制、抽象、接口等）** 、 **thinkPHP（控制器、视图、模型等）** 😝\n\n---\n\n<!-- more -->\n\n## PHP基础知识\n以下知识点所有内容都是来自官方提供的 **PHP** 文档《[PHP手册][1]》，更多细节及知识点可以查看《[PHP手册][2]》。\n\n如果你平时用 **Windows** 系统，可以使用 [WAMP][3] 来搭建一个本地的开发环境。如果你是 **OSX** ，可以使用 [MAMP][4] 来搭建一个开发环境。\n### PHP语法\n#### 认识PHP\nPHP 代码被包含在特殊的起始符和结束符 `<?php` 和 `?>` 中，使得可以进出“PHP 模式”。如果文件都是 **PHP** 代码，可以省略结束标记，但是必须以 `;` 结束。\n\n```html\n<body>\n  <h1>php</h1>\n  <?php\n    echo \"lishaoying\";\n    $name = '李少颖';\n    echo \"hello: \" . $name ;\n  ?>\n</body>\n```\n结果会输出：`lishaoyinghello: 李少颖`, **PHP** 解析器会解析开始`<?php` 和结束标记 `?>` 之间的内容。\n\n---\n#### 变量\n**PHP** 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。\n```php\n<?php\n\n$name = 'lishaoy.net';\necho \"hello $name \\r\\n\";\n```\n结果会输出：`hello lishaoy.net `。\n\n---\n#### 字符串\n在 **PHP** 里面定义一个字符串，可以使用单引号`' '`或者双引号`\" \"`。\n```php\n<?php\n\n$email = \"persilee@foxmail.com<br />\";\n```\n第三种表达字符串的方法是用 **heredoc** 句法结构：`<<<`。\n\n```php\n$word = <<< WORD\n这是一个测试 - $name 。 . <br />\n今天，天气不错，我们出去玩吧！ . <br />\nWORD;\n\necho $word;\n```\n结果会输出： `这是一个测试 - lishaoy.net 。`\n\n---\n#### 数组\n可以用 `array()` 语言结构来新建一个数组。它接受任意数量用逗号分隔的 键（**key**） `=>` 值（**value**）对。\n\n```php\n<?php\n$tracks = array(\n  0 => '长城',\n);\n\necho var_dump(\n  $tracks[0]\n);\n```\n结果会输出： `string(6) \"长城\"`。\n\n---\n#### 表单\n`$_GET`，还有 `$_POST`，这两个东西里面会存储使用不同的方法提交的表单的内容，`$_GET` 里面存储的是用 **GET** 方法提交的表单内容。\n\n```html\n<body>\n  <form class=\"\" action=\"process.php\" method=\"get\">\n    <input type=\"text\" name=\"user_name\" value=\"\" placeholder=\"用户名\">\n    <input type=\"email\" name=\"email\" value=\"\" placeholder=\"Email\">\n    <button type=\"submit\">提 交</button>\n  </form>\n</body>\n```\n**process.php**文件内容：\n\n```php\n<?php\necho '<pre>';\n  var_dump(\n    $_GET['user_name']\n  );\necho '</pre>';\n```\n点提交之后会把文本框的内容传递到**process.php**文件处理，这里会输出文本框的输入内容。\n\n---\n#### 数据库\n**PDO** 类，代表 **PHP** 和数据库服务之间的一个连接。\n\n```php\n$db_handle = new PDO('mysql:host=127.0.0.1;dbname=msg;port=8889;charset=utf8','msg_test','123');\n```\n这样就可以创建一个和数据库的连接。\n```php\n<?php\n\ntry {\n  $db_handle = new PDO('mysql:host=127.0.0.1;dbname=msg;port=8889;charset=utf8','msg_test','123');\n\n$statement = $db_handle->prepare(\n  'insert into posts(title, content) values (:title, :content)'\n);\n\n$title = 'Wall-e';\n$content = 'wall-e已经在地球上孤独生活了几百年，他爱上了。。。';\n\n$statement->bindParam(':title', $title);\n$statement->bindParam(':content', $content);\n\n$statement->execute();\n\n} catch (Exception $e) {\n  echo $e->getMessage();\n}\n```\n可以向数据库的**posts**表插入一条数据。\n\n---\n### 面向对象\n#### 创建Class\n每个类的定义都以关键字 `class` 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。\n```php\nclass Track\n{\n    \n}\n```\n\n---\n#### 增加属性\n类的变量成员叫做“**属性**”，或者叫“**字段**”、“**特征**”，在本文档统一称为“**属性**”。\n```php\nclass Track\n{\n    public $track_name;\n    public $track_artist;\n}\n```\n\n---\n#### 继承\n**继承** 将会影响到类与类，对象与对象之间的关系。\n\n比如，当扩展一个类，子类就会**继承**父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被**继承**的方法都会保留其原有功能。\n```php\n<?php\n\nclass Player extends Track\n{\n\n}\n```\n\n---\n#### 访问控制\n对属性或方法的访问控制，是通过在前面添加关键字 `public`（公有），`protected`（受保护）或 `private`（私有）来实现的。被定义为公有的类成员可以 **在任何地方被访问**。被定义为受保护的类成员则可以 **被其自身以及其子类和父类访问**。被定义为私有的类成员则 **只能被其定义所在的类访问**。\n\n---\n#### 静态属性与方法\n声明类属性或方法为**静态**( `static` )，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。\n```php\nclass Track\n{\n    public static $track_name = 'Magic';\n    public $track_artist;\n    \n    public static function track_playing() {\n        return '正在播放' . self::$track_name;\n    }\n}\n```\n\n---\n#### 构造函数\n具有**构造函数**( `__construct` )的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。\n```php\n<?php\n\nclass Track\n{\n    public $track_name;\n    public $track_artist;\n    \n    public function __construct() {\n        echo '初始化数据...';\n    }\n    \n    public function track_playing() {\n        return '正在播放' . $this->$track_name;\n    }\n}\n```\n\n---\n#### 构造器与获取器\n在给不可访问属性赋值时，`__set()` 会被调用。\n读取不可访问属性的值时，`__get()` 会被调用。\n```php\n<?php\n\nclass Track\n{      \n    private $track_name;\n    private $track_artist;\n\n    public function __set($name, $value) {\n        if (property_exists($this, $name)) {\n            $this->$name = $value;\n        }\n    }\n    \n    public function __get($name) {\n        return $this->$name;\n    }\n\n    public function track_playing() {\n        return '正在播放' . $this->$track_name;\n    }\n}\n```\n\n---\n#### 抽象类\n**定义为抽象的类不能被实例化**( `abstract` )。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。\n```php\n<?php\n\nabstract class Entity\n{\n    protected $entity_type;\n    public function get_entity_type() {\n        return $this->entity_type;\n    }\n    \n    abstract public function save();\n}\n\nclass User extends Entity\n{\n    protected $entity_type = 'user';\n    \n    public function save() {\n        return $this->entity_type . '：保存成功！';\n    }\n}\n```\n\n---\n#### 接口\n使用 **接口**（ `interface `），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。\n\n**接口** 是通过 `interface` 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。\n\n**接口** 中定义的所有方法都必须是公有，这是接口的特性。\n```php\n<?php\n\ninterface DataInterface \n{\n    public function get_data();\n}\n\ninterface EntityInterface\n{\n    public function get_entity_type();\n}\n\nclass Entity implements DataInterface, EntityInterface\n{\n    public function get_data() {\n        return '数据...';\n    }\n    \n    public function get_entity_type() {\n        return '类型...';\n    }\n}\n```\n\n---\n## ThinkPHP\n以下内容基本都是来自**ThinkPHP**[官方文档][5]，更多细节及知识点可查看 [官方文档][5]。\n### 基础\n#### 环境要求\n**PHP版本要求**\n- PHP5.3以上版本\n\n**支持的服务器和数据库环境**\n- 支持Windows/Unix服务器环境\n- 可运行于包括Apache、IIS和nginx在内的多种WEB服务器和模式\n- 支持Mysql、MsSQL、PgSQL、Sqlite、Oracle、Ibase、Mongo以及PDO等多种数据库和连接\n\n如果你平时用 **Windows** 系统，可以使用 [WAMP][6] 来搭建一个本地的开发环境。如果你是 **OSX** ，可以使用 [MAMP][7] 来搭建一个开发环境。\n\n---\n#### 目录结构\n初始的目录结构如下：\n```vim\nwww  WEB部署目录（或者子目录）\n├─index.php       入口文件\n├─README.md       README文件\n├─Application     应用目录\n├─Public          资源文件目录\n└─ThinkPHP        框架目录\n```\n其中框架目录**ThinkPHP**的结构如下：\n```vim\n├─ThinkPHP 框架系统目录（可以部署在非web目录下面）\n│  ├─Common       核心公共函数目录\n│  ├─Conf         核心配置目录 \n│  ├─Lang         核心语言包目录\n│  ├─Library      框架类库目录\n│  │  ├─Think     核心Think类库包目录\n│  │  ├─Behavior  行为类库目录\n│  │  ├─Org       Org类库包目录\n│  │  ├─Vendor    第三方类库目录\n│  │  ├─ ...      更多类库目录\n│  ├─Mode         框架应用模式目录\n│  ├─Tpl          系统模板目录\n│  ├─LICENSE.txt  框架授权协议文件\n│  ├─logo.png     框架LOGO文件\n│  ├─README.txt   框架README文件\n│  └─ThinkPHP.php    框架入口文件\n```\n\n---\n#### 入口文件\n**ThinkPHP**采用单一入口模式进行项目部署和访问，无论完成什么功能，一个应用都有一个统一（但不一定是唯一）的入口。\n\n**入口文件主要完成：**\n- 定义框架路径、项目路径（可选）\n- 定义调试模式和应用模式（可选）\n- 定义系统相关常量（可选）\n- 载入框架入口文件（**必须**）\n\n```php\n// 开启调试模式 建议开发阶段开启 部署阶段注释或者设为false\ndefine('APP_DEBUG',true);\n\n// 定义应用目录\ndefine( 'APP_PATH', dirname(__FILE__).'/Application/' );\n\n//生成后台模块\ndefine('BIND_MODULE','Admin');\n\n// 引入ThinkPHP入口文件\nrequire dirname( __FILE__).'/ThinkPHP/ThinkPHP.php';\n```\n\n---\n#### URL\n入口文件是应用的单一入口，对应用的所有请求都定向到应用入口文件，系统会从URL参数中解析当前请求的模块、控制器和操作：\n\n```vim\nhttp://serverName/index.php/模块/控制器/操作\n```\n\n---\n### 控制器\n#### 控制器定义\n一般来说，ThinkPHP的控制器是一个类，而操作则是控制器类的一个公共方法。\n下面就是一个典型的控制器类的定义：\n```php\nnamespace Admin\\Controller;\nuse Think\\Controller;\n\nclass LoginController extends Controller {\n    public function hello(){\n        echo 'hello,thinkphp!';\n    }\n}\n```\n在浏览器里访问：`http://msg:8899/index.php/Login/hello`，会显示：`hello,thinkphp!`。\n\n---\n#### AJAX返回\n**ThinkPHP** 可以很好的支持AJAX请求，系统的\\Think\\Controller类提供了ajaxReturn方法用于AJAX调用后返回数据给客户端。\n```php\n<?php\n\nnamespace Admin\\Controller;\nuse Think\\Controller;\n\nclass LoginController extends Controller {\n    public function login()\n    {\n      $data['status']  = 1;\n      $data['content'] = 'content';\n      $this->ajaxReturn($data);\n    }\n}\n```\n\n---\n#### 跳转和重定向\n\n**页面跳转**\n\n在应用开发中，经常会遇到一些带有提示信息的跳转页面，例如操作成功或者操作错误页面，并且自动跳转到另外一个目标页面。系统的`\\Think\\Controller`类内置了两个跳转方法`success`和`error`，用于页面跳转提示，而且可以支持ajax提交。\n\n```php\n    public function jump()\n    {\n      $posts = D('posts'); //实例化User对象\n      $data['title'] = 'cat';\n      $data['content'] = '猫，属于猫科动物，分家猫、野猫，是全世界家庭中较为广泛的宠物。';\n      $result = $posts->add($data);\n      if($result){\n          //设置成功后跳转页面的地址，默认的返回页面是$_SERVER['HTTP_REFERER']\n          $this->success('新增成功','Login/login');\n      } else {\n          //错误页面的默认跳转页面是返回前一页，通常不需要设置\n          $this->error('新增失败');\n      }\n    }\n```\n\n**重定向**\n\n`Controller`类的`redirect`方法可以实现页面的重定向功能。\n\n```php\n//重定向到New模块的Category操作\n$this->redirect('New/category', array('cate_id' => 2), 5, '页面跳转中...');\n```\n上面的用法是停留5秒后跳转到`New`模块的`category`操作，并且显示页面跳转中字样，重定向后会改变当前的**URL**地址。\n\n---\n\n#### 输入变量\n\n**获取变量**\n\n`I`方法是**ThinkPHP**用于更加方便和安全的获取系统输入变量，可以用于任何地方，用法格式如下：\n```php\nI('变量类型.变量名/修饰符',['默认值'],['过滤方法'],['额外数据源'])\n```\n\n变量类型是指请求方式或者输入类型，包括：\n\n|  变量类型   |   含义    |\n| :-------- | :--------| \n| get    |   获取GET参数 | \n| post    |   获取POST参数 | \n| param    |   自动判断请求类型获取GET、POST或者PUT参数 | \n| request    |   获取REQUEST 参数 | \n| put    |   获取PUT 参数 | \n| session    |   获取 $_SESSION 参数 | \n| cookie    |   获取 $_COOKIE 参数 | \n| server    |   获取 $_SERVER 参数 | \n| globals    |   获取 $GLOBALS参数 |\n| path    |   获取 PATHINFO模式的URL参数（3.2.2新增） |\n| data    |   获取 其他类型的参数，需要配合额外数据源参数（3.2.2新增） |\n\n我们以`GET`变量类型为例，说明下 `I` 方法的使用：\n\n```php\npublic function variable()\n{\n    $data['title'] = I('get.title');\n    $data['content'] = I('get.content');\n    dump($data);\n    $this->display();\n}\n```\n输出结果：\n```vim\narray(2) {\n  [\"title\"] => string(6) \"啊啊\"\n  [\"content\"] => string(6) \"啊啊\"\n}\n```\n\n---\n### 视图\n#### 模板定义\n\n每个模块的模板文件是独立的，为了对模板文件更加有效的管理，**ThinkPHP**对模板文件进行目录划分，默认的模板文件定义规则是：\n```php\n视图目录/[模板主题]/控制器名/操作名+模板后缀\n```\n默认的视图目录是模块的 **View** 目录（模块可以有多个视图文件目录，这取决于你的应用需要），框架的默认视图文件后缀是`.html`。 新版模板主题默认是空（表示不启用模板主题功能）。\n\n在每个模板主题下面，是以模块下面的控制器名为目录，然后是每个控制器的具体操作模板文件，例如：\n\n例如**Login**下的**variable**，对应的模板文件：`Admin/View/Login/variable.html`\n\n---\n#### 模板赋值\n\n如果要在模板中输出变量，必须在在控制器中把变量传递给模板，系统提供了assign方法对模板变量赋值，无论何种变量类型都统一使用assign赋值。\n```php\npublic function variable()\n    {\n      $data['title'] = I('get.title');\n      $data['content'] = I('get.content');\n      $this->assign($data);\n      $this->display();\n    }\n```\n`assign`方法必须在`display`和`show`方法之前调用，并且系统只会输出设定的变量，其它变量不会输出（系统变量例外），一定程度上保证了变量的安全性。\n\n赋值后，就可以在模板文件中输出变量了，如果使用的是内置模板的话，就可以这样输出： `{$title}`。\n\n---\n#### 渲染模板\n渲染模板输出最常用的是使用`display`方法，调用格式：\n```vim\ndisplay('[模板文件]'[,'字符编码'][,'输出类型'])\n```\n如果没有按照模板定义规则来定义模板文件（或者需要调用其他控制器下面的某个模板），可以使用：\n```php\n// 指定模板输出\n$this->display('edit'); \n```\n表示调用当前模块下面的`edit`模板\n```php\n$this->display('Member:read');\n```\n表示调用`Member`模块下面的`read`模板。\n\n---\n### 模型\n\n#### 模型定义\n> 模型类并非必须定义，只有当存在独立的业务逻辑或者属性的时候才需要定义。\n\n模型类通常需要继承系统的\\Think\\Model类或其子类，下面是一个Home\\Model\\UserModel类的定义：\n```php\n<?php\nnamespace Admin\\Model;\nuse Think\\Model;\n\nclass PostsModel extends Model{\n \n}\n```\n模型类的作用大多数情况是操作数据表的，如果按照系统的规范来命名模型类的话，大多数情况下是可以自动对应数据表。\n\n#### 模型实例化\n在ThinkPHP中，可以无需进行任何模型定义。\n\n根据不同的模型定义，我们有几种实例化模型的方法，根据需要采用不同的方式：\n**直接实例化**\n可以和实例化其他类库一样实例化模型类，例如：\n```php\n$User = new \\Home\\Model\\UserModel();\n$Info = new \\Admin\\Model\\InfoModel();\n// 带参数实例化\n$New  = new \\Home\\Model\\NewModel('blog','think_',$connection);\n```\n**D方法实例化**\n上面实例化的时候我们需要传入完整的类名，系统提供了一个快捷方法 **D** 用于数据模型的实例化操作。\n```php\n<?php\npublic function jump()\n    {\n      $posts = D('posts'); //实例化posts对象\n    }\n```\n\n**M方法实例化模型**\n**D** 方法实例化模型类的时候通常是实例化某个具体的模型类，如果你仅仅是对数据表进行基本的  **CURD** 操作的话，使用 **M** 方法实例化的话，由于不需要加载具体的模型类，所以性能会更高。\n\n```php\n// 使用M方法实例化\n$User = M('User');\n// 和用法 $User = new \\Think\\Model('User'); 等效\n// 执行其他的数据操作\n$User->select();\n```\n#### CURD操作\n**ThinkPHP**提供了灵活和方便的数据操作方法，对数据库操作的四个基本操作（CURD）：创建、更新、读取和删除的实现是最基本的，也是必须掌握的，在这基础之上才能熟悉更多实用的数据操作方法。\n\n**CURD** 操作通常是可以和连贯操作配合完成的。\n\n**创建数据对象**\n\n**ThinkPHP**可以帮助你快速地创建数据对象，最典型的应用就是自动根据表单数据创建数据对象，这个优势在一个数据表的字段非常之多的情况下尤其明显。\n\n```php\n// 实例化User模型\n$User = M('User');\n// 根据表单提交的POST数据创建数据对象\n$User->create();\n```\n\n**数据写入**\n\n**ThinkPHP**的数据写入操作使用`add`方法，使用示例如下：\n```php\n    public function jump()\n    {\n      $posts = D('posts'); //实例化User对象\n      $data['title'] = 'cat';\n      $data['content'] = '猫，属于猫科动物，分家猫、野猫，是全世界家庭中较为广泛的宠物。';\n      $result = $posts->add($data);\n```\n\n**读取数据**\n\n读取数据是指读取数据表中的一行数据（或者关联数据），主要通过`find`方法完成，例如：\n```php\npublic function getPosts(){\n      $posts = D('posts'); //实例化posts对象\n\n      $posts->where('id=1')->find();\n\n      dump($posts);\n    }\n```\n`find`方法查询数据的时候可以配合相关的连贯操作方法，其中最关键的则是where方法。\n\n**更新数据**\n\n更新数据使用`save`方法，例如：\n```php\npublic function savePosts(){\n      $posts = D('posts'); //实例化posts对象\n      $data['title'] = 'dog';\n      $data['content'] = '狗，（拉丁文:Canis lupus familiaris,英文名称dog）中文亦称“犬”，狗属于食肉目，分布于世界各地。狗与马、牛、羊、猪、鸡并称“六畜”。有科学家认为狗是由早期人类从灰狼...';\n      $posts->where('id=1')->save($data);\n    }\n```\n\n**数据删除**\n\n**ThinkPHP**删除数据使用`delete`方法，例如：\n```php\npublic function deletePosts(){\n      $posts = D('posts'); //实例化posts对象\n\n      $posts->delete(4);\n    }\n```\n表示删除主键为**4**的数据\n\n#### 连贯操作\n**ThinkPHP**模型基础类提供的连贯操作方法（也有些框架称之为链式操作），可以有效的提高数据存取的代码清晰度和开发效率，并且支持所有的**CURD**操作。\n\n使用也比较简单， 假如我们现在要查询一个**User**表的满足状态为**1**的前**10**条记录，并希望按照用户的创建时间排序 ，代码如下：\n```php\n$User->where('status=1')->order('create_time')->limit(10)->select();\n```\n这里的`where`、`order`和`limit`方法就被称之为连贯操作方法，除了`select`方法必须放到最后一个外（因为select方法并不是连贯操作方法），连贯操作的方法调用顺序没有先后。\n\n  [1]: http://php.net/manual/zh/index.php\n  [2]: http://php.net/manual/zh/index.php\n  [3]: http://wampserver.com\n  [4]: https://www.mamp.info/en/\n  [5]: http://document.thinkphp.cn/manual_3_2.html#preface\n  [6]: http://wampserver.com\n  [7]: https://www.mamp.info/en/","tags":["thinkPHP"],"categories":["PHP"]},{"title":"浅谈JavaScript作用域","url":"%2FjavascriptScope.html","content":"\n{% fi javascriptScope/javascriptScope01.png, ,  %}\n\n我们在面试时，总会碰到一些奇奇怪怪的关于 **作用域** 的面试题，其实弄清楚原理，万变不离其宗，大部分的面试题都可以得 '姐'。 \n\n所以，今天我们来谈谈 `JavaScript` 的 **作用域(javascript scope)** ，这是老生常谈的话题，这里我们会从 **作用域** 开始，会延伸到 **预解析规则（预编译） 、 变量提升 、函数提升 、表达式 、语句 、IIFE 、 匿名函数表达式 、 具名函数表达式** 等，彻底搞明白作用域这些事 🤓\n\n---\n\n<!-- more -->\n\n### 变量提升和函数提升\n\n在开始阐述之前，我们来看一段代码，看看结果是什么？\n\n```javascript\nalert(a);\nfunction a(){ alter(2); }\nalert(a);\nvar a = 1\nalert(a);\nvar a = 3;\nalert(a);\nfunction a(){ alter(4); }\nalert(a);\na();\n```\n\n这里先揭晓答案：\n{% note success %} \n- 第一个 `alert(a)`  弹出 `function a(){ alter(4); }` 函数体\n- 第二个 `alter(a)`  弹出 `function a(){ alter(4); }` 函数体\n- 第三个 `alter(a)`  弹出 **1**\n- 第四个 `alter(a)`  弹出 **3**\n- 第五个 `alter(a)`  弹出 **3**\n- 最后一行报错 `a is not a function`\n{% endnote %}  \n\n下面来分析一下这段代码：\n其实在 `javascript` 开始执行代码之前，有一个 **预解析（预编译）** 的过程，这个过程会产生 **变量提升** 和 **函数提升** ，其实整个执行过程可以分为两部分，方便理解：\n\n1. **预解析**\n这个过程，会把 关键字 `var` 、 `function` 、 **参数** 提取出来\n\n上面这段代码 **预解析** 的过程是：\n\n```javascript\n// 第1行，没有关键字 ， 不解析\n// 第2行，遇到 function 关键字，解析到全局的头部\na = function a(){ alter(2); }\n// 第3行，没有关键字 ， 不解析\n// 第4行，遇到关键字 var ， 解析到全局的头部\na = undefined\n// 第5行，没有关键字 ， 不解析\n// 第6行，遇到关键字 var ， 解析到全局的头部\na = undefined\n// 第8行，遇到 function 关键字，解析到全局的头部\na = function a(){ alter(4); }\n// 第9行，没有关键字 ， 不解析\n// 第10行，a() 函数调用\n```\n\n此时这里有4个同名变量 a ，依循规则是：`function` 优先与 `var`, 同名的后面覆盖前面的\n因此，`a = function a(){ alter(2); }` 替换掉下面的2个 ~~`a = undefined`~~ ，`a = function a(){ alter(4); }` 又替换掉 ~~`a = function a(){ alter(2); }`~~ ,最终只剩下 `a = function a(){ alter(4); }`\n\n**预解析（预编译）** 后的代码样子是这样的\n\n```javascript\nvar a = function a(){ alter(4); }\nalert(a);\nalert(a);\na = 1\nalert(a);\na = 3;\nalert(a);\nalert(a);\na();\n```\n\n2. 执行代码，就是执行的这段代码，依次从上到下执行，最后的 `a()` 函数调用，这时的 `a` 已被 **表达式** 赋值成 **3** ，而报错 `a is not a function`\n\n----\n\n### 全局作用域和局部作用域\n\n再看这段代码\n\n```javascript\nvar a = 1;\nfunction fn1(){\n    alert(a);\n    var a = 2;\n}\nfn1();\nalert(a);\n```\n\n这里先揭晓答案：\n{% note success %}\n- 第一个 `alert(a)` 弹出 `undefined`\n- 第二个 `alert(a)` 弹出 **1**\n{% endnote %}\n\n`JavaScript` 的作用域只用两种，一个是全局的，一个是函数的，也称为 **全局作用域** 和 **局部作用域** ；**局部作用域** 可以访问 **全局作用域** 。但是 **全局作用域** 不能访问 **局部作用域** \n\n同样用 **预解析（预编译）** 的方法来分析这段代码\n1. **预解析（预编译）** 全局作用域\n\n```javascript\n// 第1行，遇到 var 关键字，解析到全局的头部\na = undefined\n// 第2行，遇到 function 关键字，解析到全局的头部\nfn1 = function fn1(){\n    alert(a);\n    var a = 2;\n}\n// 第3行，没有遇到关键字，不解析\n// 第4行，没有遇到关键字，不解析\n```\n\n2. 开始执行代码\n\n第1行，遇到表达式 `a = 1`, **a** 被赋值成 **1** </br>\n第6行，遇到函数调用 `fn1()` ,开始 **预解析（预编译）** 局部\n\n3. **预解析（预编译）** 局部作用域\n\n```javascript\n// 第3行，没有遇到关键字，不解析\n// 第4行，遇到 var 关键字，解析到局部\na = undefined\n```\n4. 开始执行 **局部** 代码\n\n第3行，弹出 `undefined` \n第4行，遇到表达式，把局部 **a** 改成 **2**\n\n5. 局部执行完成，继续执行全局\n\n第7行，弹出 **1** ，因为全局和局部是两个独立的作用域\n\n----\n\n### 作用域链\n\n如果，把上面👆代码，稍作修改\n\n```javascript\nvar a = 1;\nfunction fn1(){\n    alert(a);\n    a = 2;\n}\nfn1();\nalert(a);\n```\n\n去掉了 `function` 里的 `var` ，结果就会不一样\n这次，输出的是：\n- 第一个 `alert` 弹出 **1**\n- 第二个 `alert` 弹出 **2**\n因为在解析局部是没有发现 `var a` ，如是在执行时，就会去全局查找，找到了全局的 `a = 1` ，所以 第一个 `alert` 弹出 **1** ，而不是 `undefined` ,这个就是 **作用域连**\n\n----\n\n### 表达式、语句 和 IIFE\n\n在看下以下 👇 的代码\n\n```javascript\nvar b = 10;\nconsole.log(b);\n(function b() {\n    console.log(b);\n    b = 20;\n    console.log(b);\n  }\n)();\nconsole.log(b);\nfunction b() {\n    b = 30;\n    console.log(b);\n}\n```\n\n先揭晓答案：\n{% note success %}\n- 第1个 `console.log(b)` 输出的是 **10**\n- 第2个 `console.log(b)` 输出函数体 `b() {console.log(b); b = 20; console.log(b);}`\n- 第3个 `console.log(b)` 输出函数体 `b() {console.log(b); b = 20; console.log(b);}`\n- 第4个 `console.log(b)` 输出的是 **10**\n- 第5个 没有任何输出\n{% endnote %}\n\n在分析这段代码之前，我们需要掌握一点知识，什么是 **语句** ，什么是 **表达式** 以及 **IIFE**\n#### 表达式、语句\n\n`JavaScript` 程序的执行单位为行 `（line）` ，也就是一行一行地执行。一般情况下，每一行就是一个语句。\n\n语句 `（statement）` 是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。\n\n```javascript\nvar a = 1 + 3;\n```\n\n`1 + 3` 叫做表达式 `（expression）` ，指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。\n\n#### 立即执行函数 -- IIFE *（Immediately-Invoked Function Expression）*\n\n在 `Javascript` 中，圆括号 `()` 是一种运算符，跟在 **函数名** 之后，表示调用该函数。例如： `a()`\n\n有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。\n\n```javascript\nfunction(){ /* code */ }();\n// SyntaxError: Unexpected token (\n```\n\n产生这个错误的原因是，`function` 这个关键字即可以当作语句，也可以当作表达式。\n\n```javascript\n// 语句\nfunction f() {}\n\n// 表达式\nvar f = function f() {}\n```\n\n为了避免解析上的歧义，`JavaScript` 引擎规定，如果 `function` 关键字出现在行首，一律解释成语句。因此，`JavaScript` 引擎看到行首是 `function` 关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。\n\n解决方法就是不要让 `function` 出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。\n\n```javascript\n(function(){ /* code */ }());\n// 或者\n(function(){ /* code */ })();\n```\n\n上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式” *（Immediately-Invoked Function Expression）* ，简称 **IIFE**。\n\n了解这些知识之后，再来分析上面 👆 提到的这段代码\n\n先拆开来分析下代码，把这段单独拿出来，看看 👀\n\n```javascript\n(function b() {\n    console.log(b);\n    b = 20;\n    console.log(b);\n  }\n)();\n```\n\n其实这段是可以单独运行的，结果是\n\n{% note success %}\n- 第1个 `console.log(b)` 输出函数体 `b() {console.log(b); b = 20; console.log(b);}`\n- 第2个 `console.log(b)` 输出函数体 `b() {console.log(b); b = 20; console.log(b);}`\n{% endnote %}\n\n再来分析下原因，很明显这个就是一个 **IIFE** , 由一个 **函数表达式** 和 圆括号 `()` 运算符组成，上面 👆 这段代码和下面 👇 是等价的\n\n```javascript\nvar b = function b() {\n    console.log(b);\n    b = 20;\n    console.log(b);\n}();\n```\n\n再来分析，就比较容易理解了\n\n- **首先开始解析**\n\n```javascript\nb = undefined; //第一行 遇到 var 关键字，变量提升\n```\n解析完之后的样子\n\n```javascript\nvar b;\nb = function b() {\n    console.log(b);\n    b = 20;\n    console.log(b);\n};\nb();\n```\n\n- **执行代码**\n\n第2行，遇到 **表达式语句** 将 `b(){console.log(b); b = 20; console.log(b);}` 赋值给 `b`  \n第7行，调用函数，开始局部解析\n\n局部解析没有发现关键字 `var` 和 `function` ，没有任何动作\n\n继续执行 **局部** 代码\n\n第3行， `console.log(b)` 输出外部的 `b = b(){console.log(b); b = 20; console.log(b);}` </br>\n第4行， 由第3行可知，此时， `b` 是个内部函数体，而不是外部变量 `b` ，解析器只会把 `b = 20;` 当成普通 **表达式** ，而不是 **表达式语句** ，不会进行赋值操作 </br>\n第5行， `b` 的值没有任何改变，依然输出函数体 `b = b(){console.log(b); b = 20; console.log(b);}` </br>\n\n最终，回到最开始代码本身\n\n```javascript\nvar b = 10;\nconsole.log(b);\n(function b() {\n    console.log(b);\n    b = 20;\n    console.log(b);\n  }\n)();\nconsole.log(b);\nfunction b() {\n    b = 30;\n    console.log(b);\n}\n```\n**预解析：**\n\n```javascript\nb = undefined; //变量提升\nb = function b() { //函数提升\n    b = 30;\n    console.log(b);\n}\n```\n\n遵循，函数 `一等公民` 原则，函数优先级高于变量， ~~`b = undefined;`~~ 被干掉\n\n预解析之后，应该是这个样子\n\n```javascript\nvar b = function b() {\n    b = 30;\n    console.log(b);\n}\nb = 10;\nconsole.log(b);\n(function b() {\n    console.log(b);\n    b = 20;\n    console.log(b);\n})();\nconsole.log(b);\n```\n再来看下答案，就很清楚了\n\n{% note success %}\n- 第1个 `console.log(b)` 输出的是 **10**\n- 第2个 `console.log(b)` 输出函数体 `b() {console.log(b); b = 20; console.log(b);}`\n- 第3个 `console.log(b)` 输出函数体 `b() {console.log(b); b = 20; console.log(b);}`\n- 第4个 `console.log(b)` 输出的是 **10**\n- 第5个 没有任何输出，由于函数提升，最终 被 `b = 10` 覆盖\n{% endnote %}\n\n这里，可以把上面 👆 代码稍作改动，结果会不一样，如：\n\n```javascript\nvar b = 10;\nconsole.log(b);\n(function b() {\n    console.log(b);\n    var b = 20;  // ++++ 加了 var\n    console.log(b);\n  }\n)();\nconsole.log(b);\nfunction b() {\n    b = 30;\n    console.log(b);\n}\n```\n\n这里就不揭晓答案了，感兴趣的，可自行思考 🤔 ，看看 👀 最终答案如何。。。\n\n----\n### 匿名函数表达式、具名函数表达式\n\n在来看看这段代码👇\n\n```javascript\nvar a = 3;\nfunction fn() {\n    foo();\n    function foo() {\n        console.log(1);\n    }\n    foo();\n    var foo = function() {\n        console.log(2);\n    };\n    foo();\n    var bar = function foo() {\n        if(a > 3) return;\n        console.log(++a);\n        foo();\n    };\n    foo();\n    bar();\n}\nfn();\n```\n先揭晓答案：\n{% note success %}\n- 第1个 `foo()` 输出的是 **1**\n- 第2个 `foo()` 输出的是 **1**\n- 第3个 `foo()` 输出的是 **2**\n- 第4个 `foo()` 输出的是 **2**\n- 最后的 `bar()` 输出的是 **4**\n{% endnote %}\n\n以上代码包含了 **函数声明** 、 **匿名函数表达式** 、 **具名函数表达式** ，**匿名函数表达式** 、 **具名函数表达式** 是把函数体赋值给一个变量，因此拥有和变量相同的特性 **变量提升** ，而 **具名函数表达式** 的函数名只能在函数内部使用。\n\n了解了这些，再来分析段代码\n\n- **全局预解析**\n\n```javascript\na = undefined\nfn = function fn(){\n    ...\n}\n```\n- **执行代码**\n第1行，遇到表达式,把 **a** 的值改变成3 </br>\n最后行，遇到函数调用，重新 **预解析** 局部\n\n- **局部预解析**\n\n```javascript\n// 第4行，遇到 function 关键字，解析到局部的头部\nfoo = function(){\n    console.log(1);\n}\n// 第8行，遇到 var 关键字，解析到局部的头部\nfoo = undefined\n// 第12行，遇到 var 关键字，解析到局部的头部\nbar = undefined\n```\n\n由于有两个同名变量 `foo` ，遵循 `function` 优先 `var` 因此， ~~`foo = undefined`~~ 被干掉\n\n**局部预解析** 完之后的代码应该是这个样子👇\n\n```javascript\nvar a = 3\nfunction fn() {\n    var foo = function foo() {\n        console.log(1);\n    }\n    var bar;\n    foo();\n    foo();\n    foo = function foo() {\n        console.log(2);\n    };\n    foo();\n    bar = function foo() {\n        if(a > 3) return;\n        console.log(++a);\n        foo();\n    };\n    foo();\n    bar();\n}\nfn();\n```\n\n- **执行局部代码** </br>\n第1个 `foo()` 输出的是 **1** </br>\n第2个 `foo()` 输出的是 **1** </br>\n第3个 `foo()` 输出的是 **2** </br>\n第4个 `foo()` 输出的是 **2** ，注意这个 `foo()` 输出的是上面 `foo = function foo() {console.log(2);}` 的内容，因为 **具名函数表达式** 的函数名只能在函数内部使用，在外部无法访问。</br>\n最后的 `bar()` 输出的是 **4** ，这里才是输出 `function foo() {if(a > 3) return;console.log(++a);foo();}` 里的内容，而且，这个函数体内也有自身的调用，结果 `a` 变量 **+1** ，说明可以调用，其实，可以用 `bar.name` 输出的就是 `foo`\n\n**所以，注意：**\n\n{% note danger %}\n- `bar = function foo()` , 不要用这种写法 ，优雅的写法是 **变量名** 和 **函数名** 保持一致 `foo = function foo()`\n- 不推荐使用 **匿名函数表达式** ，有以下 👇 几个缺点\n    * 在追踪栈中没函数名，调试困难\n    * 如果需要引用自身，只能用非标准的 `arguments.callee`（ES5严格模式禁用）\n{% endnote %}","tags":["变量提升"],"categories":["JS"]},{"title":"初 ☘ 夏 ☀️","url":"%2Fsummer.html","content":"\n{% fi summer/summer01.png %}\n<div class=\"text-center\">\n**七月的风懒懒的 连云都变热热的 夏天的风正暖暖吹过 穿过头发穿过耳朵……**\n</div>\n\n---\n<table class=\"per-table\">\n    <tr>\n        <td>**摄影/后期：**</td>\n        <td>子木</td>\n    </tr>\n    <tr>\n        <td>**模特：**</td>\n        <td>Danny</td>\n    </tr>\n    <tr>\n        <td>**地点：**</td>\n        <td>花卉世界</td>\n    </tr>\n    <tr>\n        <td>**拍摄于：**</td>\n        <td>2015年7月12</td>\n    </tr>\n</table>\n\n<!-- more -->\n\n</br>\n\n<img src=\"summer/summer02.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer04.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer01.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer08.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer05.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer09.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer06.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer07.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"summer/summer03.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />","tags":["摄影"],"categories":["摄影"]},{"title":"girlfriends","url":"%2FshenzhenUuniversity.html","content":"\n{% fi shenzhenUuniversity/girlfriends02.png %}\n<div class=\"text-center\">\n**悲伤一起哭，欢乐一起笑，好书一起读，好歌一起听……**\n</div>\n\n---\n<table class=\"per-table\">\n    <tr>\n        <td>**摄影/后期：**</td>\n        <td>子木</td>\n    </tr>\n    <tr>\n        <td>**模特：**</td>\n        <td>Donna and cherry</td>\n    </tr>\n    <tr>\n        <td>**地点：**</td>\n        <td>深圳大学天台</td>\n    </tr>\n    <tr>\n        <td>**拍摄于：**</td>\n        <td>2015年8月23</td>\n    </tr>\n</table>\n\n<!-- more -->\n\n</br>\n\n<img src=\"shenzhenUuniversity/girlfriends01.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"shenzhenUuniversity/girlfriends02.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"shenzhenUuniversity/girlfriends03.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"shenzhenUuniversity/girlfriends04.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"shenzhenUuniversity/girlfriends05.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"shenzhenUuniversity/girlfriends06.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />","tags":["深圳大学"],"categories":["摄影"]},{"title":"猫吧","url":"%2FcatBar20150927.html","content":"\n{% fi catBar20150927/catBar04.png %}\n<div class=\"text-center\">\n**很久之前拍的照片,猫吧里貌似有5只大肥猫 🐱 ...</i>**\n</div>\n\n---\n<table class=\"per-table\">\n    <tr>\n        <td>**摄影/后期：**</td>\n        <td>子木</td>\n    </tr>\n    <tr>\n        <td>**模特：**</td>\n        <td>👩‍⚖️‍ </td>\n    </tr>\n    <tr>\n        <td>**地点：**</td>\n        <td>深圳福田 🐱 </td>\n    </tr>\n    <tr>\n        <td>**拍摄于：**</td>\n        <td>2015年9月27</td>\n    </tr>\n</table>\n\n<!-- more -->\n\n</br>\n\n<img src=\"catBar20150927/catBar01.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar02.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar03.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar04.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar05.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar06.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar07.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar09.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar10.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar11.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar08.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />\n\n<img src=\"catBar20150927/catBar12.png\" alt=\"hexo\" width=\"100%\" align=\"center\" />","tags":["照片"],"categories":["摄影"]},{"title":"如何用 CSS + HTML + JS 创建桌面应用","url":"%2FnwjsElectronjs.html","content":"\n最近研究了一下基于 `Chromium` 定制浏览器的方案，查阅了大量资料，具体方案也有了大概的蓝图 😉 \n\n----\n\n<!-- more -->\n\n在阐述方案之前，先要了解几个名词：\n\n### 简介\n\n#### Chromium\n\n>Chromium是一个由Google主导开发的网页浏览器，以BSD许可证等多重自由版权发行并开放源代码。Chromium的开发可能早自2006年即开始。\n\n>Chromium是Google为发展自家的浏览器Google Chrome而打开的项目，所以Chromium相当于Google Chrome的工程版或实验版（尽管Google Chrome本身也有β版），新功能会率先在Chromium上开放，待验证后才会应用在Google Chrome上，故Google Chrome的功能会相对落后但较稳定。 —— [维基百科](https://zh.wikipedia.org/wiki/Chromium#cite_note-3)\n\n#### CEF\n\n>Chromium Embedded Framework (CEF)是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Mac平台。除了提供C/C++接口外，也有其他语言的移植版。\n\n>因为基于Chromium，所以CEF支持Webkit & Chrome中实现的HTML5的特性，并且在性能上面，也比较接近Chrome。\nCEF还提供的如下特性：自定义插件、自定义协议、自定义JavaScript对象和扩展；可控制的resource loading, navigation, context menus等等  —— [百度百科](https://baike.baidu.com/item/CEF/20837917?fr=aladdin)\n\n#### NW\n\n>NW.js 是基于 Chromium 和 Node.js 运行的， 以前也叫nodeWebkit。这就给了你使用HTML和JavaScript来制作桌面应用的可能。在应用里你可以直接调用Node.js的各种api以及现有的第三方包。因为Chromium和 Node.js 的跨平台，那么你的应用也是可以跨平台的。—— [SegmentFault][1]\n\n#### Electron\n\n>Electron（最初名为Atom Shell）是GitHub开发的一个开源框架。它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端与后端的开发，著名项目包括GitHub的Atom和微软的Visual Studio Code。—— [维基百科][2]\n\n所以 ，**CEF**、**nw**、**Electron** 都是基于 `Chromium` 的开源框架，可以实现所需的定制浏览器需求，准确的讲应该是用 `HTML5` 、 `CSS3` 、 `JavaScript` 来制作拥有漂亮界面的**桌面应用**。\n\n就是一个本地客户端应用程序使用一个内置的浏览器内核渲染前端界面，另一方面还可以调用本地系统级API，实现本地应用程序的各种功能。\n\n------\n\n### 市场调研\n\n通过查阅大量资料得知，以各企业的线上产品及使用的技术供参考。\n\n#### CEF 案例\n\n据 **CEF** 官方介绍，以下（如图）桌面应用在使用 `CEF`。\n\n<img src=\"https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/CEF.png?raw=true\" alt=\"CEF\" width=\"85%\" title=\"who is using CEF\" align=\"center\" />\n\n国内桌面应用有：[有道云笔记][3] <i style=\"color:#aaa\">（网易）</i>、[钉钉][4]<i style=\"color:#aaa\">（阿里巴巴）</i>、[QQ][5]<i style=\"color:#aaa\">（腾讯）</i> 等，查看安装后目录及文件，可以看出 **有道云笔记**、**钉钉** 是使用的是`CEF`，而 **钉钉** 界面是使用 `AngularJs`，据了解后端应该用了`C++`和`Python`。\n\n**QQ** 很早之前就通过内嵌 **IE** 来实现一些功能和界面。从2013年开始，**QQ** 引入了 `CEF`，对一些之前用 **IE** 的地方进行了替换。\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520329975606.png?raw=true \"钉钉Mac版目录\")\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520330256871.png?raw=true \"钉钉Mac版应用界面\")\n\n#### NW 案例\n\n这个是 **[NW](https://nwjs.io)** 官方给出的使用 `nw.js` 的应用列表：[https://github.com/nwjs/nw.js/wiki/List-of-apps-and-companies-using-nw.js][6] \n\n而国内的有，比如微信开发工具等，是基于 `nw.js` 开发的。\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520571438918.png?raw=true \"微信开发工具Mac版目录\")\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520571517344.png?raw=true \"微信开发工具Mac版\")\n\n#### Electron 案例\n\n这个是 **[Electron](https://electronjs.org)** 官方给出的是用 `electron` 的应用列表：[https://electronjs.org/apps](https://electronjs.org/apps)\n\n如图，**Electron** 已被像 **微软**、 **Facebook**、 **Slack** 和 **Docker** 这样的公司用于创建应用程序。\n\n<img src=\"https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520668439676.png?raw=true\" alt=\"electron\" width=\"85%\" title=\"electron 应用\" align=\"center\" />\n\n我所用的编辑器 **Visual Studio Code** 就是基于 `electron` 开发的\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520669844227.png?raw=true \"VS Code Mac版\")\n \n ----\n\n### 实战\n\n下面会分别用 `nw.js` 和 `electron` 做一个简单的 **Dome**。\n\n由于 **CEF** 文档资料少且原生是 `C\\C++` ，虽然官方给出了 `java` 版的 **JCEF** ，开发起来效率较低，故此不知演示。\n\n这个是 **[CEF][7]** 官网，在 *External Projects* 章节列出支持语言：\n\n> - Net (CEF3) - https://github.com/cefsharp/CefSharp\n> - Net (CEF1) - https://bitbucket.org/fddima/cefglue\n> - Net/Mono (CEF3) - https://bitbucket.org/xilium/xilium.cefglue\n> - Net (CEF3) - https://bitbucket.org/chromiumfx/chromiumfx\n> - Delphi (CEF1) - http://code.google.com/p/delphichromiumembedded/\n> - Delphi (CEF3) - https://github.com/hgourvest/dcef3\n> - Delphi (CEF3) - https://github.com/salvadordf/CEF4Delphi\n> - Go - https://github.com/CzarekTomczak/cef2go\n> - Java - https://bitbucket.org/chromiumembedded/java-cef\n> - Java - http://code.google.com/p/javacef/\n> - Python - http://code.google.com/p/cefpython/\n\n#### NW => Hello, world!\n\n从一个简单的例子来让我们看看如何编写一个 **NW** 应用。\n\n- **第一步** 创建 `package.json` 配置文件\n\n```vim\n{\n    \"name\": \"helloworld\",\n    \"main\": \"index.html\",\n    \"icon\": \"img/app.png\",\n    \"window\": {\n        \"icon\": \"img/app.png\"\n    }\n}\n```\n`main` 配置应用打开首页，`name` 配置应用的名称。\n\n- **第二步** 创建 `index.html` \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Holle NW</title>\n</head>\n<style>\n    html,\n    body {\n        height: 100%;\n        margin: 0;\n    }\n\n    .box {\n        height: 100%;\n        display: flex; /* css3 弹性盒子 */\n        justify-content: center;\n        align-items: center;\n    }\n</style>\n\n<body>\n    <div class=\"box\">\n        <h1>Holle NW!</h1>\n    </div>\n</body>\n\n</html>\n```\n这是一个简单的 **HTML** 文件，加入了一点CSS，目的是让 **Holle NW!** 水平垂直居中。\n\n- **第三步** 打包应用\n\n这里我只测试了 **Mac** 和 **Windows** 的打包，**Linux** 没有测试。\n\n**Mac打包应用：** 在项目根目录执行以下命令，把所有文件压缩成 `app.nw` 文件。\n\n```vim\nzip -r app.nw *\n```\n\n然后把`app.nw` 文件放到 `nwjs.app/Contents/Resources/` 目录下即可，效果如图：\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520711078780.png?raw=true \"Mac下运行效果\")\n\n**Windows打包应用：**  将应用的所有相关文件打成一个名为`package.nw` 的压缩包，将`package.nw` 与**NW**可执行文件放到相同目录即可，效果如图：\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520711343860.png?raw=true \"Windons下运行效果 \")\n\n-----\n\n#### Electron => Hello, world!\n\n**Electron** 可以让你使用纯 `JavaScript` 调用丰富的原生(操作系统) **APIs** 来创造桌面应用。\n\n只需3个文件就可以构建一个简单的应用\n\n```zsh\nyour-app/\n  ├── package.json\n  ├── main.js\n  └── index.html\n```\n\n- **第一步** 创建配置文件\n\n首先需要安装 **Node** 环境，用 `npm` 来创建一个应用的配置文件 `package.json`\n\n```vim\nnpm init\n```\n\n在 `package.json` 里新增启动命令 `start` \n\n```vim\n{\n    \"name\": \"your-app\",\n    \"version\": \"0.1.0\",\n    \"main\": \"main.js\",\n    \"scripts\": {\n      \"start\": \"electron .\"\n    }\n  }\n```\n\n- **第二步** 创建入口文件 `main.js`\n\n```javascript\nconst {app, BrowserWindow} = require('electron');\nconst path = require('path')\nconst url = require('url')\n\nfunction createWindow() {\n    win = new BrowserWindow({\n        width: 1008,\n        height: 759\n    })\n      \n    win.loadURL(url.format({\n        pathname: path.join(__dirname, 'index.html'),\n        protocol: 'file:',\n        slashes: true\n    }))\n}\n\napp.on('ready', createWindow)\n```\n\n代码已经很清晰直观，`createWindow` 创建一个桌面窗口，而大小由 `width`、`height` 控制，`win.loadURL` 用来加载页面。\n\n- **第三步** 创建展示文件 `index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Hello Electron</title>\n</head>\n<style>\n    html,\n    body {\n        height: 100%;\n        margin: 0;\n    }\n\n    .box {\n        height: 100%;\n        display: flex;\n        /* css3 弹性盒子 */\n        justify-content: center;\n        align-items: center;\n    }\n</style>\n\n<body>\n    <div class=\"box\">\n        <h1>Hello Electron!</h1>\n    </div>\n</body>\n\n</html>\n```\n这是一个简单的 **HTML** 文件，加入了一点CSS，目的是让 **Holle NW!** 水平垂直居中。\n\n- **第四步** 打包应用\n\n**打包应用：** 打包应用可以是用 `electron-packager` 工具进行打包，需要在 `package.json` 配置以下命令\n\n```json\n\"scripts\": {\n    \"start\": \"electron .\",\n    \"packager\": \"electron-packager ./ HelloElectron --all --out ./OutApp --version 0.0.1 --overwrite --ignore=node_modules --icon=./app/img/app.ico\"\n  },\n```\n\n然后，运行在终端执行命令 `npm run packagerMac` 即可打包`linux`、`Mac`、`windows` 三大平台应用包，效果如图：\n\n<img src=\"https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520791859473.png?raw=true\" alt=\"打包后的应用\" width=\"60%\" title=\"打包后的应用\" align=\"center\" />\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520790145115.png?raw=true \"Mac下运行效果\")\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520792416456.png?raw=true \"Windows下运行效果\")\n\n----\n\n### GitHub关注度和活跃度\n\n首先我们需要先了解一下 **GitHub** 的以下三个状态的意思，\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520857435681.png?raw=true)\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520857536175.png?raw=true) ：表示你以后会关注这个项目的所有动态，这个项目以后只要发生变动，如被别人提交了 `pull request`、被别人发起了`issue` 等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520857569746.png?raw=true)：表示你喜欢这个项目或者通俗点，可以把他理解成朋友圈的点赞，表示对这个项目的支持。\n\n![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520857709924.png?raw=true)：当选择 `fork`，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步。<i style=\"color:#aaa\">（一般用于修改**bug**和优化项目或者在此项目上开发新功能等）</i>\n\n#### CEF\n\n**CEF** 在 **GitHub** 找不到项目，这个[官网][8] 提供的数据，如图<i style=\"color:#aaa\">（由于在**GitHub** 没有项目，相关数据无法准确统计）</i>。\n\n![CEF关注度](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520855809138.png?raw=true \"CEF关注度\")\n\n#### NW\n\n**NW关注度：** ![Alt text](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520856387728.png?raw=true)\n\n**NW活跃度：**如图\n\n![2011年~2018年提交量](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520858064076.png?raw=true \"2011年~2018年提交量\")\n\n#### Electron\n\n**Electron关注度：** ![no-shadow](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520858325207.png?raw=true)\n\n**活跃度：** 如图\n\n![electron2013年~2018年提交量](https://github.com/persilee/nwjs_electronjs/blob/master/desktop_application/1520858451333.png?raw=true \"electron2013年~2018年提交量\")\n\n----\n\n通过以上的 **市场调研**、**实战**、**GitHub关注度和活跃度** 等 **Electron** 都占有优势，如下\n\n-  市场案例较多，各大型企业都在使用\n-  开发实战代码更直观，容易理解和维护，各种文档健全、网络资料较多且质量较高，周边辅助工具齐全，开发效率可大大提高\n-  **GitHub** 关注度和活跃度持续攀升\n\n所有结合以上情况，之后会用以下技术栈做一个完善的案例\n\n- **跨平台桌面应用框架：**`electron`  <i style=\"color:#aaa\">（Chromium + Node.js）</i>\n- **UI库：** `iView`\n- **js框架：** `Vue.js`\n- **自动化构建工具：**  `webpack`\n- **HTML5、CSS3、ES6**\n\n\n  [1]: https://segmentfault.com/a/1190000003870613\n  [2]: https://zh.wikipedia.org/wiki/Electron_%28%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6%29\n  [3]: http://note.youdao.com\n  [4]: https://www.dingtalk.com/?source=2202&lwfrom=2017120202092064209309201\n  [5]: https://im.qq.com/pcqq/\n  [6]: https://github.com/nwjs/nw.js/wiki/List-of-apps-and-companies-using-nw.js\n  [7]: https://bitbucket.org/chromiumembedded/cef\n  [8]: https://bitbucket.org/chromiumembedded/cef/overview","tags":["桌面应用"],"categories":["Node"]},{"title":"用 Hexo Next GitHubPages 搭建漂亮的免费博客","url":"%2FhexoGithubpagesNext.html","content":"{% fi hexoGithubpagesNext/git_hexo.jpeg, GitHubPages + Hexo, GitHubPages + Hexo %}\n<div class=\"text-center\">\n    <h3>今天搭建了自己的博客 😝</h3>\n</div>\n\n花费了 **一天半** 的时间，终于把我的 **个人博客** 搭建完成，下面我写下搭建博客的过程，其实挺简单的 🙃\n\n---\n\n<!-- more -->\n\n### 博客所用技术 （Hexo + Next + GitHubPages）\n\n在文章的末尾我会 **贴出** 我基于 **Hexo + Next + GitHubPages** 搭建博客，所参考的文章链接。\n\n如果，你也想用这些技术搭建漂亮的博客，你就需要了解下 `Hexo` 、 `Next` 、 `GitHubPages` 这三个单词，下面会逐个解释。\n\n####  什么是 Hexo\n> **Hexo** 是一个快速、简洁且高效的博客框架。**Hexo** 使用 *Markdown*（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 -- [Hexo](https://hexo.io/zh-cn/docs/index.html)\n\n####  什么是 Next\n\n> **NexT** 是 **Hexo**的一个主题（theme），拥有丰富而简单的配置，结合第三方服务，可以打造属于您自己的博客。 -- [Next](http://theme-next.iissnan.com)\n\n#### 什么是 GitHubPages\n\n> GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository. -- [GitHubPages](https://help.github.com/articles/what-is-github-pages/)\n\n**翻译过来大概是：** GitHub页面是一个静态的站点托管服务，旨在从GitHub存储库中直接托管您的个人、组织或项目页面。\n\n所以，`Hexo` 、 `Next` 、 `GitHubPages` 配合起来就可以免费搭建漂亮的 **个人博客** , 是不是很爽 😆\n\n----\n### 如何\b基于 \bHexo 搭建博客\n\n基于 \bHexo 搭建博客，只需简单的几步，就能完成 **个人博客** 的搭建。\n\n#### \b准备工作\n\n##### 下载安装 \b`nodejs`\n\n`node` 会自带 \b`npm` 包管理工具，*建议安装* `yarn` 来管理依赖 （\b因为 `hexo` 貌似是用 `yarn` 管理 **依赖** 的，否则可以回出现 **依赖\b** 问题）。\n\n**Mac** 用户可以用 `brew` 安装，**Windows** 可以用 `cmder` 或去官网下安装包程序。\n\n```\bvim\n    brew install node\n```\n\n然后用 \b`npm` 安装 `yarn`\n\n```vim\n    npm install yarn\n```\n\n##### 安装\b `git`\n\n**Mac\b** 用户可用刚安装的 `yarn` 包管理工具安装 `git`，**Windows** 可以 `cmder` 或去官网下安装包程序。\n\n```vim\n    yarn add git -g\n```\n\n##### 安装 `hexo`\n\n进入你的项目目录，比如我的是 `myblog` ，\n\n```vim\n    cd myblog\n```\n\n然后用 `\byarn` 安装 `hexo`。\n\n```vim\n    yarn add hexo -S\n```\n\n此时，环境都准备好了，就可以开始搭建 **\bhexo** 博客了 😜\n\n----\n#### 搭建本地博客\n\n##### 进入你的项目目录\n\n比如：我的是 `myblog`。\n\n```vim\n    cd myblog\n```\n\n##### 项目初始化\n\n项目初始化，会自动生成博客模板，以后写博客只需用 `markdown` 语法编写对应的 `.md` 文件即可 ✍️ 。\n\n```vim\n    hexo init\n```\n##### 安装所有的依赖 \n\n建议使用用 `yarn` ，否则会出现依赖问题（*在本文之后有相关介绍*）。\n\n```vim\n    yarn install\n```\n##### 最后，启动本地服务\n\n在浏览器输入 `localhost:4000` 即可预览博客\n\n```vim\n    hexo server\n```\n\n**如图:** 🌁 </br>\n<img src=\"hexoGithubpagesNext/hexoinit.png\" alt=\"hexo\" width=\"100%\" title=\"hexo最初的样子 😂\" align=\"center\" />\n\n----\n### 关联 GitHub\n\n通过 **GitHub** 的 `pages` 功能，我们可以把我们的博客托管到 **GitHub** ，而无需去购买云服务器 😋 ,轻松愉快的构建免费博客。\n\n#### 创建 GitHub 账户\n\n我相信 🤔 大家应该都有 **GitHub** 账号了，如果没有可去 [GitHub](https://github.com/) 官网按照步骤创建账户即可。\n\n#### 配置关联 GitHub\n\n- 有了 **GitHub** 账号之后，登录 **GitHub** ，创建一个项目，项目名称最好和你本地的项目一致，比如： `myblog`\n\n{% note danger %}\n项目建好之后，一定要开启 **GitHub Pages** 功能 ⚠️\n{% endnote %}\n\n- 点击如图 `Settings` 开启，**GitHub Pages** 功能\n\n<img src=\"hexoGithubpagesNext/gitpages.png\" alt=\"GitHubPages\" width=\"100%\" title=\"GitHubPages Settings\" align=\"center\" />\n\n- 选择 `master branch` , 然后 **Save** \n\n<img src=\"hexoGithubpagesNext/gitpages2.png\" alt=\"GitHubPages\" width=\"100%\" title=\"GitHubPages Source\" align=\"center\" />\n\n- 复制你的项目连接，如图\n\n<img src=\"hexoGithubpagesNext/gitpages3.png\" alt=\"GitHubPages\" width=\"100%\" title=\"GitHubPages URL\" align=\"center\" />\n\n- 然后在你本地项目根目录找到 `_config.yml` 文件，粘贴到以下位置\n\n```yml\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/persilee/MyBlog.git\n  branch: master\n```\n\n#### 完成关联\n\n完成以上步骤之后，就可以把自己本地项目推送到 **GitHub** 托管，只剩下3步 😋\n\n1. 安装 `hexo-deployer-git` 插件（可以通过简单的命令,完成文件生成及推送功能）\n\n```vim\n    yarn add hexo-deployer-git -S\n```\n\n2. 运行 `hexo g` （生成本地文件）\n\n```vim\n    hexo g\n```\n\n3. 运行 `hexo d` （将本地文件推送到 **GitHub** ，和 `git push` 功能相同）\n\n```vim\n    hexo d\n```\n此时，**GitHub** 应该已给你生成了访问连接，连接格式是: `你的账号名称` + `.github.io` + `\\项目名称`,也可以去刚才 `GitHubPages` 设置页面查看\n例如我的：[https:\\\\persilee.github.io\\MyBlog](https:\\\\persilee.github.io\\MyBlog)\n\n这时，你就可以把连接发给小伙伴们，他们通过连接都可以访问你的 **博客** 🙃。\n\n{% note danger %}\n**这里需要注意的地方是：在执行 `hexo g` 命令时候，可能会出现以下 `error`,应该是 `yarn` 和 `npm` 冲突的依赖的问题，所以前面文章建议使用 `yarn` 管理包依赖**\n{% endnote %}\n\n```vim\nERROR Plugin load failed: hexo-renderer-marked\nError: EISDIR: illegal operation on a directory, read\nERROR Plugin load failed: hexo-server\nError: EISDIR: illegal operation on a directory, read\nERROR Plugin load failed: hexo-renderer-stylus\nError: EISDIR: illegal operation on a directory, read\n```\n\n解决办法，先用 `yarn` 分别移除，再重新安装，如下\n\n```vim\n## 先移除\nyarn remove hexo-renderer-marked\n\nyarn remove hexo-renderer-stylus\n\nyarn remove hexo-server\n\n## 再安装\nyarn add hexo-renderer-marked -S \n\nyarn add hexo-renderer-stylus -S\n\nyarn add hexo-server -S\n```\n\n在执行 `hexo g` ,顺利执行 👌\n\n----\n\n### 绑定域名\n\n我们已经可以通过 **GitHub** 分发给我的地址访问 **博客** ，但是，这对于我们这些爱 **折腾** 的 **程序猿👨‍💻‍** 来说，还不够，弄个自己的 **域名** 才够拉风😂。\n\n于是。。。\n\n开始绑定自己的 **域名** [lishaoy.net](https://lishaoy.net)\n\n然而，我们绑定 **域名** 之后，只支持 `http` 协议，这样我们在 **Google** 浏览器访问时，会有不安全标准，而且，很容易被插入广告，于是。。。**折腾** 走起🌝：搞个 `https`\n\n转入正题，经过一番 **折腾** ，采用第三方服务 [Netlify](https://app.netlify.com/sites/lishaoy/settings/domain#ssl-tls-certificate) 来提供免费的SSL/TLS证书。\n\n当然，这里我提供2种方式绑定域名，一种是 `HTTP` (不安全的网络协议)、一种是 `HTTPS` （安全的网络协议，在 **Google** 浏览器上回有一把小锁，如图）\n\n<img src=\"hexoGithubpagesNext/lock.png\" alt=\"Netlity\" width=\"100%\" title=\"Google HTTPS 状态标识\" align=\"center\" />\n\n#### `HTTP` 绑定域名\n\n##### 设置域名解析规则\n\n首先，我们需要去运行商，新增域名解析规则，如图\n\n<img src=\"hexoGithubpagesNext/domain.png\" alt=\"domain\" width=\"100%\" title=\"域名解析规则\" align=\"center\" />\n\n##### 新增 `CNAME` 文件\n\n配置好域名解析规则之后，还需要在项目的 `.\\source\\` 路径下新增 `CNAME` 文件，输入内容 `你的域名` ,如：[lishaoy.net](https://lishaoy.net)\n##### 重新新生成文件，推送到GitHub\n\n重新生成文件，运行 `hexo g`\n\n```vim\n    hexo g\n```\n推送 **GitHub**\n\n```vim\n    hexo d\n```\n\n-----\n\n#### `HTTPS` 绑定域名\n##### 注册 `Netlify` 账号\n\n首先，我们需要注册一个 [Netlify](https://app.netlify.com/sites/lishaoy/settings/domain#ssl-tls-certificate) 账号，地址：[Netlify](https://app.netlify.com/sites/lishaoy/settings/domain#ssl-tls-certificate) ，可以选择用 **GitHub** 注册。\n\n<img src=\"hexoGithubpagesNext/netlify.png\" alt=\"Netlity\" width=\"100%\" title=\"Netlity Login\" align=\"center\" />\n\n##### 新增站点\n\n- 点击如图按钮 `New site from Git`,来新增 **站点**\n\n<img src=\"hexoGithubpagesNext/netlify1.png\" alt=\"Netlity\" width=\"100%\" title=\"New site from Git\" align=\"center\" />\n\n- 然后，点击如图按钮 `GitHub` \n\n<img src=\"hexoGithubpagesNext/netlify2.png\" alt=\"Netlity\" width=\"100%\" title=\"GitHub\" align=\"center\" />\n\n- 选择你的项目，比如我的 `MyBlog`\n\n<img src=\"hexoGithubpagesNext/netlify3.png\" alt=\"Netlity\" width=\"100%\" title=\"Select Site\" align=\"center\" />\n\n- 点击 `Deploy site`\n\n<img src=\"hexoGithubpagesNext/netlify4.png\" alt=\"Netlity\" width=\"100%\" title=\"Deploy site\" align=\"center\" />\n\n- 看到如图页面，表示成功，再点击 `Site settings` \n\n<img src=\"hexoGithubpagesNext/netlify5.png\" alt=\"Netlity\" width=\"100%\" title=\"Getting started\" align=\"center\" />\n\n<img src=\"hexoGithubpagesNext/netlify6.png\" alt=\"Netlity\" width=\"100%\" title=\"Site details\" align=\"center\" />\n\n- 再点击 `Change site name` 修改短名称，方便记忆\n\n- 在自己的域名管理中设置 **DNS** ，我使用的是 **阿里云** ，在管理界面添加如图规则\n\n<img src=\"hexoGithubpagesNext/netlify7.png\" alt=\"Netlity\" width=\"100%\" title=\"设置域名规则\" align=\"center\" />\n\n- 在点击 `Domain management` 下的 `HTTPS` ，按照步骤完成操作，稍等片刻，即可看到我们的 **域名** 已经上锁 🔐 \n\n<img src=\"hexoGithubpagesNext/netlify8.png\" alt=\"Netlity\" width=\"100%\" title=\"lishaoy.net上锁\" align=\"center\" />\n\n😝 😜 😄 😆 😂 🤣 ...\n\n----\n### 更换 `next` 主题\n\n`hexo` 的主题很多，你可以选择其他喜欢 ❤️ 的主题，我使用的是 `next` 主题。\n\n#### 安装 `next` 主题\n\n执行以下命令，安装 `next` 主题\n\n```vim\n    git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n```\n\n#### 更改配置文件\n\n修改根目录下的 `./_config.yml` 文件，如下\n\n```vim\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n```\n\n##### 重新新生成文件，推送到GitHub\n\n重新生成文件，运行 `hexo g`\n\n```vim\n    hexo g\n```\n推送 **GitHub**\n\n```vim\n    hexo d\n```\n\n也可以运行以下命令，启动一个本地服务，调试确定无问题之后再 推送到 **GitHub** \n\n```vim\n    hexo s --debug\n```\n\n本地服务启动后，可以在浏览器输入 `http://localhost:4000` 预览，如图\n\n<img src=\"hexoGithubpagesNext/nextpage.png\" alt=\"next\" width=\"100%\" title=\"next 主题最初的样子🙃\" align=\"center\" />\n\n**本文到此告一段落，关于 `next` 主题美化的问题，可以参考以下链接文章 🤗**\n\n以下是我搭建 **博客** 参考的文章链接 👇 \n\n{% note default %} \n\n- [hexo的next主题个性化教程:打造炫酷网站](http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html)\n- [Hexo搭建博客教程](https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/)\n- [Hexo博客搭建全攻略(二)：NexT主题配置](https://www.jianshu.com/p/d95cff938277)\n\n {% endnote %}\n","tags":["Next"],"categories":["hexo"]}]